![image](https://github.com/user-attachments/assets/7e9f6d66-9aa2-4944-8c32-e18f31d195b6)# kim_java_advanced_1

## **멀티태스킹과 멀티프로세싱**
### **멀티태스킹**
- 몇가지의 프로그램 태스크(Code)가 하나의 프로세서(CPU)에게 수행을 하게끔 하는 작업 수행.
이렇게 되면 프로그램이 동시에 실행되는 느낌을 받을 수 있다.

### **멀티프로세싱**
- 둘 이상의 프로세서(CPU)를 사용하여 동시에 여러 태스크(Code)의 작업을 수행.

#### **멀티프로세싱 vs. 멀티태스킹**
- 멀티프로세싱은 하드웨어 장비의 관점이고, 멀티태스킹은 운영체제 소프트웨어의 관점이다.
#### **멀티프로세싱**
- 여러 CPU(여러 CPU 코어)를 사용하여 동시에 여러 작업을 수행하는 것을 의미한다. 하드웨어 기반으로 성능을 향상시킨다.
- 예: 다중 코어 프로세서를 사용하는 현대 컴퓨터 시스템
#### **멀티태스킹**
- 단일 CPU(단일 CPU 코어)가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것을 의미한다. 소프트웨어 기반으로 CPU 시간을 분할하여 각 작업에 할당한다.
- 예: 현대 운영 체제에서 여러 애플리케이션이 동시에 실행되는 환경



## **프로세스와 스레드 **
### **프로세스**
- 실행 중인 프로그램의 인스턴스이다. 각자의 독립적인 메모리 공간을 가지고 있으며, 이에 프로세스 서로를 간섭 하지 않는다.
두가지의 프로세스가 충돌이 나더라도 잘 못된 프로세스만 종료 되고 다른 프로세스는 그대로 진행한다.

#### **프로세스의 메모리 구성**
- **코드 섹션**: 실행할 프로그램의 코드가 저장되는 부분
- **데이터 섹션**: 전역 변수 및 정적 변수가 저장되는 부분(그림에서 기타에 포함)
- **힙 (Heap)**: 동적으로 할당되는 메모리 영역
- **스택 (Stack)**: 메서드(함수) 호출 시 생성되는 지역 변수와 반환 주소가 저장되는 영역(스레드에 포함)

### **스레드**
- 스레드는 프로세스 안에서 실행되는 작업의 단위이며, 하나의 프로세스 안에는 여러가지의 스레드가 존재한다.
스레드는 영문 해석으로 '실' 이라고도 하며, 단일 그리고 멀티가 존재한다. 이에 무조건 하나의 프로세스 안에는 무조건 하나의 스레드가 필요하다.

#### **멀티스레드가 필요한 이유**
- 하나의 프로그램도 그 안에서 동시에 여러 작업이 필요하다.
워드 프로그램으로 문서를 편집하면서, 문서가 자동으로 저장되고, 맞춤법 검사도 함께 수행된다. 유튜브는 영상을 보는 동안, 댓글도 달 수 있다.
운영제체 관점에서 보면 다음과 같이 구분할 수 있다.

ex) **워드 프로그램 - 프로세스A**
- 스레드1: 문서 편집
- 스레드2: 자동 저장
- 스레드3: 맞춤법 검사

ex) **유튜브 - 프로세스B**
- 스레드1: 영상 재생
- 스레드2: 댓글



## **스레드와 스케줄링** 
### **스케줄링**
-  CPU에 어떤 프로그램이 얼마만큼 실행될지는 운영체제가 결정하는데 이것을 스케줄링(Scheduling)이라 한다.
-  즉 운영체제가 스케줄링을 수행하고, CPU를 최대한 사용하면서 작업이 골고루 수행될 수 있게 최적화한다는 정도로 이해하면 충분


## **컨텍스트 스위칭**
### **사람의 멀티태스킹**
- 비유를 하자면 내가 프로그램A를 개발하고 있는데, 갑자기 기획자가 프로그램B를 수정해달라고 한다. 프로그램A의 개 발을 멈추고, 프로그램B를 수정한다고 가정해보자. 여기서 프로그램B의 수정을 잘 마치고, 다시 프로그램A를 개발하기
위해 돌아간다. 이때 먼저 프로그램A의 어디를 개발하고 있었는지 해당 코드의 위치를 찾아야 한다. 그리고 개발할 때 변수들을 많이 선 언하는데, 변수들에 어떤 값들이 들어가는지 머리속에 다시 불러와야 한다.
**만약 프로그램A의 개발이 다 끝나고 나서, 프로그램B를 수정한다면, 전체 시간으로 보면 더 효율적으로 개발할 수 있을 것이다.**

### **컴퓨터의 멀티태스킹**
- 운영체제의 멀티태스킹을 생각해보자. CPU 코어는 하나만 있다고 가정하자. 스레드A, 스레드B가 있다.
운영체제는 먼저 스레드A를 실행한다. 멀티태스킹을 해야 하기 때문에 스레드A를 계속 실행할 수 없다. 스레드A를 잠 시 멈추고, 스레드B를 실행한다. 이후에 스레드A로 그냥 돌아갈 수 없다. CPU에서 스레드를 실행하는데, 스레드A의 코드가 어디까지 수행되었는지 위치를 찾아야 한다. 그리고 계산하던 변수들의 값을 CPU에 다시 불러들여야 한다. 따 라서
**스레드A를 멈추는 시점에 CPU에서 사용하던 이런 값들을 메모리에 저장해두어야 한다. 그리고 이후에 스레드A 를 다시 실행할 때 이 값들을 CPU에 다시 불러와야 한다.**

  ### **컨텍스트 스위칭**
- 위와 같은 과정을 **컨텍스트 스위칭(context switching)**이라 한다.
컨텍스트는 현재 작업하는 문맥을 뜻한다. 현재 작업하는 문맥이 변하기 때문에 컨텍스트 스위칭이다.
컨텍스트 스위칭 과정에서 이전에 실행 중인 값을 메모리에 잠깐 저장하고, 이후에 다시 실행하는 시점에 저장한 값을 CPU에 다시 불러와야 한다.
결과적으로 컨텍스트 스위칭 과정에는 약간의 비용이 발생한다.

#### **웹 애플리케이션 서버**
분야마다 다르겠지만, 실무에서는 CPU-바운드 작업 보다는 I/O-바운드 작업이 많다.
예를 들어서 백엔드 개발자의 경우 주로 웹 애플리케이션 서버를 개발하는데, 스레드가 1 ~ 10000까지 더하는 CPU의 연산이 필요한 작업보다는, 대부분 사용자의 입력을 기다리거나, 데이터베이스를 호출하고 그 결과를 기다리는 등, 기다 리는 일이 많다. 쉽게 이야기해서 스레드가 CPU를 많이 사용하지 않는 I/O-바운드 작업이 많다는 뜻이다.

**정리하면 스레드의 숫자는 CPU-바운드 작업이 많은가, 아니면 I/O-바운드 작업이 많은가에 따라 다르게 설정해야 한 다.**

**CPU-바운드 작업**: CPU 코어 수 + 1개
- CPU를 거의 100% 사용하는 작업이므로 스레드를 CPU 숫자에 최적화

**I/O-바운드 작업**: CPU 코어 수 보다 많은 스레드를 생성, CPU를 최대한 사용할 수 있는 숫자까지 스레드 생성
- CPU를 많이 사용하지 않으므로 성능 테스트를 통해 CPU를 최대한 활용하는 숫자까지 스레드 생성
- 단 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가 - 적절한 성능 테스트 필요

참고로 웹 애플리케이션 서버라도 상황에 따라 CPU 바운드 작업이 많을 수 있다. 이 경우 CPU-바운드 작업에 최적화 된 CPU 숫자를 고려하면 된다.

